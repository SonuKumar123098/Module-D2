// https://leetcode.com/problems/minimize-malware-spread/
class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n=graph.length;
        int m=initial.length;
        DSU d= new DSU(n);
        for(int i=0;i<n;i++){
            for(int j=i+1;j<n;j++){
                if(graph[i][j]==1) d.union(i,j);
            }
        }
        int infected[]=new int[n];
        Arrays.fill(infected,0);
        for(int e:initial){
            int a=d.find(e);
            infected[a]++;
        }
        Arrays.sort(initial);
        int ans=-1; int num=0;
        for(int e:initial){
            int a=d.find(e);
            if(infected[a]==1){
                if(num<d.size(a)){
                    ans=e;
                    num=d.size(a);
                }
            }
        }
        if(ans==-1){
            ans=initial[0];
            for(int i=0;i<m;i++){
                Math.min(ans,initial[i]);
            }
        }
        return ans;
    }
}
class DSU{
    private int parent[];
    private int size[];
    public DSU(int n){
        parent=new int[n];
        size=new int[n];
        for(int i=0;i<n;i++){
            parent[i]=i;
            size[i]=1;
        }
    }
    int size(int x){
        return size[x];
    }
    int find(int x){
        if(parent[x]==x)return x;
        return parent[x]=find(parent[x]);
    }
    void union(int a,int b){
        a=find(a);
        b=find(b);
        if(a!=b){
            if(size[b]>size[a]){
                int temp=a;
                a=b;
                b=temp;
            }
            size[a]+=size[b];
            parent[b]=a;
        }
    }
}
